# Multithreading-and-GUI

## Appendix
It provides the opportunity to run more than one job in the same process environment. When a process starts running, a thread (main thread) is created and more than one (multi-thread) can be created within the process. Created threads can operate in the same network and different networks. Threads can generally be used as simulations when testing software. Thanks to the system called the asynchronous approach, tasks can be carried out in parallel, without waiting. Besides, in a multi-thread application, one of the threads stops or breaks, and the application continues to run normally through other channels. Some OSs work based on real-time operations which endanger the stability and continuity of the objectives which have to be done in a given time. Because in these systems, time is tremendously critical and the possibility of not be able to finish performing in the given time may cause interference between program components. In this way, in order not to endanger the continuity of the program which are performing, it is a logical way to use multi-threading. For example, by using a multithreaded approach, it is possible to put a data acquisition operations in a thread whereas displaying it in the user interface in another thread. With that way, the OS can perform multiple threads, namely, switches the thread to perform of data acquisition thread, while the user is operating the user interface. Besides, multi-threading is really important for increasing the performance of the program and the machine. Each processor on a computer or on a machine is capable of performing one thread at a time. That is why in single-core computers, the performance can be lower in comparison to a multi-core machine. With multi-core structure, it is possible to apply multi-threading to the program which makes it safer and much efficient. Lastly, for a particular task, using multithreading can provide an opportunity for the program to work parallel with each component of it. For example, one of the threads can receive the data to be processed whereas the other one processes them. And, resultantly, another thread can transmit the response of the received data. By using some built-in functions which focus on improving the efficiency and performance of creatşng and using threads as if LabWindows/CVI have, it is possible to work by not interfering any oıther system component by using thread-local variables etc. LabWindows / CVI has functions to make thread usage easier. The most used of these are Thread pool Thread-safe queues, Thread-safe variables, Thread locks. These functions can be much more diversified. Information on the use of these functions will be given during the presentation.

6.2) Cyclic Redundancy Check(CRC) Cyclic Redundancy Check is a function that detects errors in data transmission. There should not be any error while sending or receiving data, and when it does, problems such as some missing parts may be encountered when sending a message to someone. This function is used to prevent this, and in case of any error, the data is sent again and again until it is transmitted without any problem. Thousands of errors must occur in a short time to have a speed loss or delay noticeable by human If these errors do not increase significantly, it would be extremely difficult to detect without any algorithm. Therefore, CRC algorithms should be used for full data validation. CRCs are specifically designed to protect against error types that are common in communication channels. They can realize the consistency of the delivered messages quickly and securely. However, they are not suitable for the changes made in the data by request. If data is degraded in the transmission line, it must be recognized and the data retransmitted. At the end of data transmission, the CRC tries to verify the message over and over again until it is ensured that all the data has been transmitted completely correctly. To determine a CRC code, it is necessary to define an arbitrary polynomial code. In this polynomial, the division algorithm contains divisor, divisor, division and remainder. The important thing here is that the polynomial coefficients are calculated under the arithmetic of the finite field.
